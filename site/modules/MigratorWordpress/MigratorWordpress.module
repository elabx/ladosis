<?php

set_time_limit(10000);


// Abstraction Class
require_once(dirname(__DIR__) . '/ProcessMigrator/MigratorAbstract.php');



/**
 * WordPress Importer class for managing parsing of WXR files.
 */
class MigratorWordpress extends MigratorAbstract implements Module, ConfigurableModule {

    /**
     * getModuleInfo is a module required by all modules to tell ProcessWire about them
     *
     * @return array
     *
     */
    public static function getModuleInfo() {
        return array(
            'title' => 'Wordpress Migrator',
            'version' => 2.1,
            'summary' => 'Add new Import Wordpress XML option to Migrator.',
            'requires' => 'ProcessMigrator',
            'filetype' => 'xml',
            'icon'     => 'wordpress'
        );
    }



    // define the mainly used vars
    private $old, $new;



    // default field and template names

    private $default = array(
        'general' => array(
            'convertshortcodes' => 0
        ),
        'field' => array(
            'title'      => 'title',
            'date'       => 'date',
            'body'       => 'body',
            'headline'   => 'headline',
            'images'     => 'images',
            'files'      => 'files',
            'categories' => 'categories',
            'tags'       => 'tags',
            'excerpt'    => 'excerpt',
            'wpid'       => 'wpid',
            'comments'   => 'comments'
        ),
        'template' => array(
            'tags'       => 'tags',
            'tag'        => 'tag',
            'categories' => 'categories',
            'category'   => 'category',
            'posts'      => 'posts',
            'post'       => 'post',
            'blog-page'  => 'blog-page'
        )
    );

    private $customNames;


    /* required by Migrator Abstract */


    public function convertToJson($src) {
        $this->migratorInit($src);

        // adds data to the array
        $this->addSettings();
        $this->addPages();
        $this->addTemplates();
        $this->addFields();



        // converts the array to json
        //return mb_convert_encoding(json_encode($this->getNew(), JSON_UNESCAPED_UNICODE), "HTML-ENTITIES", 'UTF-8');
        //return mb_convert_encoding(json_encode($this->getNew()), "HTML-ENTITIES", 'UTF-8');
        return json_encode($this->getNew());
        //return json_encode($this->getNew(), JSON_UNESCAPED_UNICODE);
        //return mb_convert_encoding(json_encode($this->getNew(), JSON_UNESCAPED_UNICODE), 'UTF-8');
    }




    private function migratorInit($xml) {
        //Retrieve the Whole Configuration Data from the Class
        $data = $this->modules->getModuleConfigData($this);

        //Dynamically set the Configs using setter's method
        $this->customNames = $this->populateDefault($data);

        // parse the xml file
        $parser = new WXR_Parser;
        $parsed = $parser->parse($xml);

        // fill the private vars
        $this->old['users']        = $parsed['authors'];
        $this->old['base_url']     = $parsed['base_url'];
        $this->old['pages']        = $this->sortByPostType($parsed['posts']);
        /*Comments are in $parsed['post']['comments']*/
        $this->old['categories']   = $parsed['categories'];
        $this->old['tags']         = $parsed['tags'];




        // F**K YOU wordpress
        // Because of recent changes we have to check if tags are ony included
        // in the post (import 1.1 and newer) or excluded (older than import 1.1)

        // get categories from posts and add them to the array
        if(empty($this->old['categories'])) {
            $this->old['categories'] = $this->getCategories();
        }

        // get tags from posts and add them to the array
        if(empty($this->old['tags'])) {
            $this->old['tags'] = $this->getTags();
        }


    }





    // load


    public function getNew() {
        return $this->new;
    }


    public function addSettings() {
        $this->new['settings'][] = array(
            "base_url" => $this->old['base_url'],
            "thumb_suffix" => "-{width}x{height}"
        );
        return $this->new['settings'];
    }


    // This function adds everything contained in the PW "page tree"
    // ToDo: Comment support + custom field support
    public function addPages() {

        // --- TAGS ---

        // create the parent page
        $parent = array(
            'name' => 'tags',
            'parent_name' => '/',
            'page_template' => $this->customNames['template']['tags'],
            'status' => 1,
            'sort' => 4,
            'sortfield' => 'title',
            'data' => array(
                $this->customNames['field']['title'] => 'Tags'
            )
        );

        // add the parent to the "pages" part of the (later) json tree
        $this->new['pages'][] = $parent;


        // add the categories
        $tags = $this->old['tags'];
        if(count($tags) > 0) {
            foreach($tags as $tag) {
                $this->new['pages'][] = $this->convertTag($tag);
            }
        }


        // --- CATEGORIES ---

        // create the parent page
        $parent = array(
            'name' => 'categories',
            'parent_name' => '/',
            'page_template' => $this->customNames['template']['categories'],
            'status' => 1,
            'sort' => 3,
            'sortfield' => 'title',
            'data' => array(
                $this->customNames['field']['title'] => 'Categories'
            )
        );

        // add the parent to the "pages" part of the (later) json tree
        $this->new['pages'][] = $parent;


        // add the categories
        $categories = $this->old['categories'];
        if(count($categories) > 0) {
            foreach($categories as $category) {
                $this->new['pages'][] = $this->convertCategory($category);
            }
        }


        // --- POSTS ---

        // create the parent page
        $parent = array(
            'name' => 'posts',
            'parent_name' => '/',
            'page_template' => $this->customNames['template']['posts'],
            'status' => 1,
            'sort' => 2,
            'sortfield' => '-created',
            'data' => array(
                $this->customNames['field']['title'] => 'Blog Posts',
                $this->customNames['field']['headline'] => ''
            )
        );

        // add the parent to the "pages" part of the (later) json tree
        $this->new['pages'][] = $parent;


        // First step is to add all the "real" posts to the array
        if(!array_key_exists('post', $this->old['pages'])) $this->old['pages']['post'] = '';
        $posts = $this->old['pages']['post'];
        if($this->old['pages']['post'] != '') {
            foreach($posts as $post) {
                if($post['post_name'] == '') continue;
                $pwPost = $this->convertPost($post);

                if($pwPost['status'] == '8192') continue; // when trashed
                $this->new['pages'][] = $pwPost;
            }
        }


        // --- PAGES ---

        // add the pages
        if(!array_key_exists('page', $this->old['pages'])) $this->old['pages']['page'] = '';
        $pages = $this->old['pages']['page'];

        if($this->old['pages']['page'] != '') {
            foreach($pages as $page) {
                if($page['post_name'] == '') continue;
                $pwPast = $this->convertPage($page);

                if($pwPast['status'] == '8192') continue; // when trashed
                $this->new['pages'][] = $pwPast;
            }
        }

        // return everything just in case
        return $this->new['pages'];

    }




    // This function adds the needed templates
    public function addTemplates() {

        // create blog-page template
        $tplPage = $this->createTemplate($this->customNames['template']['blog-page'], array(
            'label' => 'Basic Blog Page'
        ));

        // add to array
        $this->new['templates'][] = $tplPage;



        // create posts template
        $tplPosts = $this->createTemplate($this->customNames['template']['posts'], array(
            'noParents'         => 1,
            'childTemplates'    => array($this->customNames['template']['post']),
            'allowPageNum'      => 1,
            'urlSegments'       => 1,
            'label'             => 'Blog Posts'
        ));

        // add to array
        $this->new['templates'][] = $tplPosts;



        // create post template
        $tplPost = $this->createTemplate($this->customNames['template']['post'], array(
            'noChildren' => 1,
            'parentTemplates' => array($this->customNames['template']['posts']),
            'allowChangeUser' => 1,
            'pageLabelField' => 'title',
            'label' => 'Blog Post'
        ));

        // add to array
        $this->new['templates'][] = $tplPost;



        // create categories template
        $tplCategories = $this->createTemplate($this->customNames['template']['categories'], array(
            'noParents' => 1,
            'childTemplates' => array($this->customNames['template']['category']),
            'label' => 'Categories (List)'
        ));

        // add to array
        $this->new['templates'][] = $tplCategories;



        // create category template
        $tplCategory = $this->createTemplate($this->customNames['template']['category'], array(
            'noChildren' => 1,
            'parentTemplates' => array($this->customNames['template']['categories']),
            'allowPageNum' => 1,
            'urlSegments' => 1,
            'label' => 'Category'
        ));

        // add to array
        $this->new['templates'][] = $tplCategory;



        // create tags template
        $tplTags = $this->createTemplate($this->customNames['template']['tags'], array(
            'noParents' => 1,
            'childTemplates' => array($this->customNames['template']['tag']),
            'label' => 'Tags'
        ));

        // add to array
        $this->new['templates'][] = $tplTags;



        // create tag template
        $tplTag = $this->createTemplate($this->customNames['template']['tag'], array(
            'noChildren' => 1,
            'parentTemplates' => array($this->customNames['template']['tags']),
            'label' => 'Tag'
        ));

        // add to array
        $this->new['templates'][] = $tplTag;



        // returning the array just in case
        return $this->new['templates'];
    }




    // This function fills a template prototype with data
    private function createTemplate($name, $data = array()) {
        // template array prototype
        $return = array(
            'template' => $name,
            'data' => array(
                'useRoles'              => 0,
                'childrenTemplatesID'   => 0,
                'sortfield'             => '',
                'noChildren'            => '',
                'noParents'             => 0,
                'childTemplates'        => array(),
                'parentTemplates'       => array(),
                'allowPageNum'          => 0,
                'allowChangeUser'       => 0,
                'redirectLogin'         => 0,
                'urlSegments'           => 0,
                'https'                 => 0,
                'slashUrls'             => 1,
                'altFilename'           => '',
                'guestSearchable'       => 0,
                'pageClass'             => '',
                'pageLabelField'        => '',
                'noGlobal'              => 0,
                'noMove'                => 0,
                'noTrash'               => 0,
                'noSettings'            => 0,
                'noChangeTemplate'      => 0,
                'noShortcut'            => 0,
                'noUnpublish'           => 0,
                'nameContentTab'        => 0,
                'noCacheGetVars'        => '',
                'noCachePostVars'       => '',
                'useCacheForUsers'      => 0,
                'cacheExpire'           => 0,
                'cacheExpirePages'      => array(),
                'label'                 => '',
                'tags'                  => ''
            )
        );

        // merge prototype with given data
        $return['data'] = array_merge($return['data'], $data);

        // return the template array
        return $return;
    }


    public function addFields() {



        // The fields needed for "posts" template

        $this->new['fields'][] = array(
            'name' => $this->customNames['field']['headline'],
            'label' => 'Headline',
            'description' => null,
            'template' => $this->customNames['template']['posts'],
            'flags' => 0,
            'type' => 'FieldtypeText',
            'data' => array(
                'textformatters' => array(
                    'TextformatterEntities'
                ),
                'collapsed' => 2,
                'size' => 0,
                'maxlength' => 1024
            )
        );



        // The fields needed for "blog-page" template

        $this->new['fields'][] = array(
            'name' => $this->customNames['field']['headline'],
            'label' => 'Headline',
            'description' => null,
            'template' => $this->customNames['template']['blog-page'],
            'flags' => 0,
            'type' => 'FieldtypeText',
            'data' => array(
                'textformatters' => array(
                    'TextformatterEntities'
                ),
                'collapsed' => 2,
                'size' => 0,
                'maxlength' => 1024
            )
        );


        $this->new['fields'][] = array(
            'name' => $this->customNames['field']['body'],
            'label' => 'Body',
            'description' => null,
            'template' => $this->customNames['template']['blog-page'],
            'flags' => 0,
            'type' => 'FieldtypeTextarea',
            "data" => array(
                "qtyMin" => 1,
                "qtyMax" => 10,
                "trashable" => 1,
                "size" => 0,
                "maxlength" => 2048,
                "inputfieldConfigNames" => "rows,toolbar,inlineMode,useACF,usePurifier,toggles,formatTags,extraAllowedContent,contentsCss,contentsInlineCss,stylesSet,extraPlugins,plugin_sourcedialog,removePlugins",
                "schemaClass" => "FieldtypeTextarea",
                "inputfieldClass" => "InputfieldCKEditor",
                "contentType" => 1,
                "pageLinkAbstractor" => 2,
                "rows" => 5,
                "toolbar" => "Format, Styles, -, Bold, Italic, -, RemoveFormat\r\nNumberedList, BulletedList, -, Blockquote\r\nPWLink, Unlink, Anchor\r\nPWImage, Table, HorizontalRule, SpecialChar\r\nPasteText, PasteFromWord\r\nScayt, -, Sourcedialog",
                "inlineMode" => 0,
                "useACF" => 1,
                "usePurifier" => 1,
                "formatTags" => "p;h1;h2;h3;h4;h5;h6;pre;address",
                "extraPlugins" => array("pwimage","pwlink","sourcedialog"),
                "removePlugins" => "image,magicline",
                "sortable" => 1,
                "textformatters" => array(
                    "TextformatterVideoEmbed"
                )
            )
        );


        $this->new['fields'][] = array(
            'name' => $this->customNames['field']['images'],
            'label' => 'Images',
            'description' => null,
            'template' => $this->customNames['template']['blog-page'],
            'flags' => 0,
            'type' => 'FieldtypeImage',
            'data' => array(
                'extensions' => 'gif jpg jpeg png',
                'entityEncode' => 1,
                'adminThumbs' => 1,
                'inputfieldClass' => 'InputfieldImage',
                'maxFiles' => 0,
                'descriptionRows' => 1,
                'collapsed' => 2,
                'fileSchema' => 2
            )
        );




        // The fields needed for "post" template

        $this->new['fields'][] = array(
            'name' => $this->customNames['field']['title'],
            'label' => 'Title',
            'description' => null,
            'template' => $this->customNames['template']['post'],
            'flags' => 13,
            'type' => 'FieldtypePageTitle',
            'data' => array(
                'required' => 1,
                'textformatters' => array(
                    'TextformatterEntities'
                ),
                'size' => 0,
                'maxlength' => 255
            )
        );

        $this->new['fields'][] = array(
            'name' => $this->customNames['field']['date'],
            'label' => 'Date',
            'description' => null,
            'template' => $this->customNames['template']['post'],
            'flags' => 0,
            'type' => 'FieldtypeDatetime',
            'data' => array(
                'datepicker' => 0,
                '_dateInputFormat' => 'Y-m-d',
                '_timeInputFormat' => 'g:i a',
                'dateInputFormat' => 'Y-m-d',
                'timeInputFormat' => 'g:i a'
            )
        );

        $this->new['fields'][] = array(
            'name' => $this->customNames['field']['body'],
            'label' => 'Body',
            'description' => null,
            'template' => $this->customNames['template']['post'],
            'flags' => 0,
            'type' => 'FieldtypeTextarea',
            "data" => array(
                "qtyMin" => 1,
                "qtyMax" => 10,
                "trashable" => 1,
                "size" => 0,
                "maxlength" => 2048,
                "inputfieldConfigNames" => "rows,toolbar,inlineMode,useACF,usePurifier,toggles,formatTags,extraAllowedContent,contentsCss,contentsInlineCss,stylesSet,extraPlugins,plugin_sourcedialog,removePlugins",
                "schemaClass" => "FieldtypeTextarea",
                "inputfieldClass" => "InputfieldCKEditor",
                "contentType" => 1,
                "pageLinkAbstractor" => 2,
                "rows" => 5,
                "toolbar" => "Format, Styles, -, Bold, Italic, -, RemoveFormat\r\nNumberedList, BulletedList, -, Blockquote\r\nPWLink, Unlink, Anchor\r\nPWImage, Table, HorizontalRule, SpecialChar\r\nPasteText, PasteFromWord\r\nScayt, -, Sourcedialog",
                "inlineMode" => 0,
                "useACF" => 1,
                "usePurifier" => 1,
                "formatTags" => "p;h1;h2;h3;h4;h5;h6;pre;address",
                "extraPlugins" => array("pwimage","pwlink","sourcedialog"),
                "removePlugins" => "image,magicline",
                "sortable" => 1,
                "textformatters" => array(
                    "TextformatterVideoEmbed"
                )
            )
        );


        $this->new['fields'][] = array(
            'name' => $this->customNames['field']['images'],
            'label' => 'Images',
            'description' => null,
            'template' => $this->customNames['template']['post'],
            'flags' => 0,
            'type' => 'FieldtypeImage',
            'data' => array(
                'extensions' => 'gif jpg jpeg png',
                'entityEncode' => 1,
                'adminThumbs' => 1,
                'inputfieldClass' => 'InputfieldImage',
                'maxFiles' => 0,
                'descriptionRows' => 1,
                'collapsed' => 2,
                'fileSchema' => 2
            )
        );


        $this->new['fields'][] = array(
            'name' => $this->customNames['field']['files'],
            'label' => 'Files',
            'description' => null,
            'template' => $this->customNames['template']['post'],
            'flags' => 0,
            'type' => 'FieldtypeFile',
            'data' => array(
                'extensions' => 'pdf doc docx xls xlsx gif jpg jpeg png mp3 wav zip module css png jpg gif jpeg js',
                'maxFiles' => 0,
                'entityEncode' => 1,
                'inputfieldClass' => 'InputfieldFile',
                'descriptionRows' => 1,
                'collapsed' => 2,
                'fileSchema' => 2
            )
        );


        $this->new['fields'][] = array(
            'name' => $this->customNames['field']['categories'],
            'label' => 'Categories',
            'description' => 'Select one or more categories below and drag to sort them in order of relevance. If you want a category that doesn\'t already exist, create a new one. ',
            'template' => $this->customNames['template']['post'],
            'flags' => 0,
            'type' => 'FieldtypePage',
            'data' => array(
                'derefAsPage' => 0,
                //'parent_id' => 'categories',
                'template_id' => $this->customNames['template']['category'],
                'labelFieldName' => 'title',
                'inputfield' => 'InputfieldAsmSelect',
                //'addable' => 1,
                'description' => 'Select one or more categories below and drag to sort them in order of relevance. If you want a category that doesn\'t already exist, create a new one. '
            )
        );

        //The fields needed for "comments" template

        $this->new['fields'][]=array(
            'name'=>$this->customNames['field']['comments'],
            'label'=>'Comments',
            'description'=>"Sets the Comments for the Website",
            'template'=>$this->customNames['template']['post'],
            'flags'=>0,
            'type'=>'FieldtypeComments',
            'data'=>array(
               "moderate"=>2,
                "deleteSpamDays"=>3,
                "collapsed"=>2,
                "schemaVersion"=>1
            )
        );


        $this->new['fields'][] = array(
            'name' => $this->customNames['field']['tags'],
            'label' => 'Tags',
            'description' => null,
            'template' => $this->customNames['template']['post'],
            'flags' => 0,
            'type' => 'FieldtypePage',
            'data' => array(
                'derefAsPage' => 0,
                //'parent_id' => 'tags',
                'template_id' => $this->customNames['template']['tag'],
                'labelFieldName' => 'title',
                'inputfield' => 'InputfieldPageAutocomplete',
                //'addable' => 1
            )
        );




        // The fields needed for "category" template

        $this->new['fields'][] = array(
            'name' => $this->customNames['field']['body'],
            'label' => 'Body',
            'description' => null,
            'template' => $this->customNames['template']['category'],
            'flags' => 0,
            'type' => 'FieldtypeTextarea',
            "data" => array(
                "qtyMin" => 1,
                "qtyMax" => 10,
                "trashable" => 1,
                "size" => 0,
                "maxlength" => 2048,
                "inputfieldConfigNames" => "rows,toolbar,inlineMode,useACF,usePurifier,toggles,formatTags,extraAllowedContent,contentsCss,contentsInlineCss,stylesSet,extraPlugins,plugin_sourcedialog,removePlugins",
                "schemaClass" => "FieldtypeTextarea",
                "inputfieldClass" => "InputfieldCKEditor",
                "contentType" => 1,
                "pageLinkAbstractor" => 2,
                "rows" => 5,
                "toolbar" => "Format, Styles, -, Bold, Italic, -, RemoveFormat\r\nNumberedList, BulletedList, -, Blockquote\r\nPWLink, Unlink, Anchor\r\nPWImage, Table, HorizontalRule, SpecialChar\r\nPasteText, PasteFromWord\r\nScayt, -, Sourcedialog",
                "inlineMode" => 0,
                "useACF" => 1,
                "usePurifier" => 1,
                "formatTags" => "p;h1;h2;h3;h4;h5;h6;pre;address",
                "extraPlugins" => array("pwimage","pwlink","sourcedialog"),
                "removePlugins" => "image,magicline",
                "sortable" => 1,
                "textformatters" => array(
                    "TextformatterVideoEmbed"
                )
            )
        );




        // The fields needed for "tag" template

        $this->new['fields'][] = array(
            'name' => $this->customNames['field']['body'],
            'label' => 'Body',
            'description' => null,
            'template' => $this->customNames['template']['tag'],
            'flags' => 0,
            'type' => 'FieldtypeTextarea',
            "data" => array(
                "qtyMin" => 1,
                "qtyMax" => 10,
                "trashable" => 1,
                "size" => 0,
                "maxlength" => 2048,
                "inputfieldConfigNames" => "rows,toolbar,inlineMode,useACF,usePurifier,toggles,formatTags,extraAllowedContent,contentsCss,contentsInlineCss,stylesSet,extraPlugins,plugin_sourcedialog,removePlugins",
                "schemaClass" => "FieldtypeTextarea",
                "inputfieldClass" => "InputfieldCKEditor",
                "contentType" => 1,
                "pageLinkAbstractor" => 2,
                "rows" => 5,
                "toolbar" => "Format, Styles, -, Bold, Italic, -, RemoveFormat\r\nNumberedList, BulletedList, -, Blockquote\r\nPWLink, Unlink, Anchor\r\nPWImage, Table, HorizontalRule, SpecialChar\r\nPasteText, PasteFromWord\r\nScayt, -, Sourcedialog",
                "inlineMode" => 0,
                "useACF" => 1,
                "usePurifier" => 1,
                "formatTags" => "p;h1;h2;h3;h4;h5;h6;pre;address",
                "extraPlugins" => array("pwimage","pwlink","sourcedialog"),
                "removePlugins" => "image,magicline",
                "sortable" => 1,
                "textformatters" => array(
                    "TextformatterVideoEmbed"
                )
            )
        );

        // returning the array - you know why ;)
        return $this->new['fields'];
    }



    /*

        // Old comment stuff - delete once certain new stuff is working

        {
        "name":"href",
        "label":"Website URL",
        "description":null,
        "template":null,
        "flags":1,
        "type":"FieldtypeURL",
        "data":{
        "noRelative":0,
        "addRoot":0,
        "size":0,
        "maxlength":1024
        }
        },

        {
        "name":"comments",
        "label":"Comments",
        "description":null,
        "template":"post",
        "flags":0,
        "type":"FieldtypeComments",
        "data":{
        "moderate":2,
        "deleteSpamDays":3,
        "collapsed":2,
        "schemaVersion":1
        }
        },

        {
        "name":"headline",
        "label":"Headline",
        "description":null,
        "template":"comments",
        "flags":0,
        "type":"FieldtypeText",
        "data":{
        "textformatters":[
        "TextformatterEntities"
        ],
        "collapsed":2,
        "size":0,
        "maxlength":1024
        }
        },
        {
        "name":"quantity",
        "label":"Quantity of items to show",
        "description":null,
        "template":"comments",
        "flags":1,
        "type":"FieldtypeInteger"
        },

    */






    /*
     *  Converters
     */


    // This function converts a single wp post to a pw post
    private function convertPost($post) {
        // the main page settings prototype
        $return = array(
            'name'              => $this->cleanPageName($post['post_name']),
            'parent_name'       => 'posts/',
            'page_template'     => $this->customNames['template']['post'],
            'status'            => $this->getStatus($post['status']),
            'sort'              => $post["menu_order"],
            'sortfield'         => 'sort',
            'created_users_id'  => $this->getUserWithRole($post["post_author"]),
            'modified_users_id' => $this->getUserWithRole($post["post_author"]),
            'created'           => strtotime($post["post_date_gmt"].' GMT'),
            'modified'          => strtotime($post["post_date_gmt"].' GMT'),
            'data'              => array()
        );

        // the pw-fields content
        $return['data'] = array(
            $this->customNames['field']['title']             => $post['post_title'],
            $this->customNames['field']['date']              => strtotime($post["post_date_gmt"].' GMT'),
            $this->customNames['field']['images']            => $this->extractImages($this->markupBody($post['post_content'])),
            $this->customNames['field']['files']             => array(),
            $this->customNames['field']['body']              => $this->markupBody($post['post_content']),
            $this->customNames['field']['categories']        => $this->getPostCategories($post),
            $this->customNames['field']['tags']              => $this->getPostTags($post),
            $this->customNames['field']['excerpt']           => $post["post_excerpt"],
            $this->customNames['field']['wpid']              => $post["post_id"],
            $this->customNames['field']['comments']          => (isset($post['comments']) ? $this->convertComments($post['comments']) : null )
            );



        return $return;

    }



    private function convertPage($page) {
        // the main page settings prototype
        $return = array(
            'name'              => $this->cleanPageName($page['post_name']),
            'parent_name'       => '/',
            'page_template'     => $this->customNames['template']['blog-page'],
            'status'            => $this->getStatus($page['status']),
            'sort'              => $page["menu_order"],
            'sortfield'         => 'sort',
            'created_users_id'  => $this->getUserWithRole($page["post_author"]),
            'modified_users_id' => $this->getUserWithRole($page["post_author"]),
            'created'           => strtotime($page["post_date_gmt"].' GMT'),
            'modified'          => strtotime($page["post_date_gmt"].' GMT'),
            'data'              => array()
        );

        // the pw-fields content
        $return['data'] = array(
            $this->customNames['field']['title']             => $page['post_title'],
            $this->customNames['field']['date']              => strtotime($page["post_date_gmt"].' GMT'),
            $this->customNames['field']['images']            => $this->extractImages($this->markupBody($page['post_content'])),
            $this->customNames['field']['files']             => array(),
            $this->customNames['field']['body']              => $this->markupBody($page['post_content']),
            $this->customNames['field']['excerpt']           => $page["post_excerpt"],
            $this->customNames['field']['wpid']              => $page["post_id"]

        );

        return $return;

    }



    private function convertTag($tag) {
        // the main page settings prototype
        $return = array(
            'name'              => $this->cleanPageName($tag['tag_slug']), // maybe tag_name
            'parent_name'       => 'tags/',
            'page_template'     => $this->customNames['template']['tag'],
            'status'            => 1,
            'sort'              => 0,
            'sortfield'         => 'sort',
            'created'           => time(),
            'modified'          => time(),
            'data'              => array()
        );

        // the pw-fields content
        $return['data'] = array(
            $this->customNames['field']['title']             => $tag['tag_name'],
            $this->customNames['field']['body']              => $tag['tag_description']
        );

        return $return;
    }


    private function convertComments($comments){
        //All comments code thanks to Okeowo Aderemi

        //We are expecting an array of comments
        if(!is_array($comments)):
            return null;
        endif;
        $pwComments=array();
        foreach($comments as $key=>$commentValues){
          $pwComments[]=array(
                "id"=>$commentValues['comment_id'],
                "status"=> $commentValues['comment_approved'],
                "data"=> $commentValues['comment_content'],
                "cite"=>$commentValues['comment_author'],
                "email"=>$commentValues['comment_author_email'],
                "ip"=>$commentValues['comment_author_IP'],
                "website"=>$commentValues['comment_author_url'],
                "parent_id"=>$commentValues['comment_parent'],
          );
        }
        return $pwComments;
    }

    // ToDo: Category parent
    private function convertCategory($cat) {
        // the main page settings prototype
        $return = array(
            'name'              => $this->cleanPageName($cat['category_nicename']),
            'parent_name'       => 'categories/',
            'page_template'     => $this->customNames['template']['category'],
            'status'            => 1,
            'sort'              => 0,
            'sortfield'         => 'sort',
            'created'           => time(),
            'modified'          => time(),
            'data'              => array()
        );

        // the pw-fields content
        $return['data'] = array(
            $this->customNames['field']['title']             => $cat['cat_name'],
            $this->customNames['field']['body']              => $cat['category_description']
        );

        return $return;
    }





    /*
    *   Helpers
    */


    // getting all categories because of recent changes
    private function getCategories() {
        $posts = $this->old['pages']['post'];
        $categories = array();
        foreach($posts as $post) {
            $data = @$post['terms'];

            if($data) {
                foreach($data as $term) {
                    if($term['domain'] == 'category') {
                        $categories[$term['slug']] = array(
                            'category_nicename' =>  $this->cleanPageName($term['slug']),
                            'cat_name' => $term['name'],
                            'category_description' => ''
                        );
                    }
                }
            }
        }

        return $categories;
    }


    // getting all tags because of recent changes
    private function getTags() {
        $posts = $this->old['pages']['post'];
        $tags = array();
        foreach($posts as $post) {
            $data = @$post['terms'];

            if($data) {
                foreach($data as $term) {
                    if($term['domain'] == 'post_tag') {
                        $tags[$term['slug']] = array(
                            'tag_slug' =>  $this->cleanPageName($term['slug']),
                            'tag_name' => $term['name'],
                            'tag_description' => ''
                        );
                    }
                }
            }
        }

        return $tags;
    }







    private function getUserWithRole($user) {
        // if the user has a role - add it. Otherwise add the guest role
        // Converts the user name to a sanitized format

        //return ((@$this->old['users'][$user]) ? $this->cleanPageName($user).':'.$this->old['users'][$user] : $this->cleanPageName($user).':guest');
        return $this->cleanPageName($user).':guest|author';
    }


    private function markupBody($text) {
        $text = $this->inlineCaption($this->inlineAlign($text));
        if(isset($this->customNames['general']['convertshortcodes']) && $this->customNames['general']['convertshortcodes']=='1') {
            $replace = array('[' => '[[',']' => ']]');
            $text = strtr($text, $replace);
        }
        $text = autop($text);

        return $text;
    }

    private function extractImages($text) {

        $imageArray = array();
        if (strpos($text,'<img') === false) return $imageArray; //return early if no images are embedded in html
        $dom = new DOMDocument();
        @$dom->loadHTML($text);
        $imagesField = '';
        foreach($dom->getElementsByTagName('img') as $img){
            $imageObj = new stdClass();
            $sizeStr = "-" . $img->getAttribute('width') . "x" . $img->getAttribute('height');
            $fullsizePath = str_replace($sizeStr, "", $img->getAttribute('src'));
            $imageObj->data = file_exists($fullsizePath) ? $fullsizePath : $img->getAttribute('src');
            $imageObj->description = $img->getAttribute('title');
            $imageArray[] = $imageObj;
        }

        return $imageArray;
    }


    //Remove any exisiting title tags so we don't end up with two titles tags for an img
    private function remove_img_titles($text) {

        $result = array();
        preg_match_all('|title="[^"]*"|U', $text, $result);

        foreach($result[0] as $img_tag) {
            $text = str_replace($img_tag, '', $text);
        }

        return $text;
    }



    // Wordpress [caption] to title
    function inlineCaption($text) {
        //caption text before caption close tag
        preg_match_all('%(\[caption.*])(.*)<img(.*)/>(.*)(\[/caption])%', $text, $matches, PREG_SET_ORDER);
        if($matches) {
            foreach($matches as $match) {
                if(trim(strip_tags($match[4])) == "") continue;
                $new = $match[2] . '<img title="'.trim(strip_tags($match[4])).'" '.$match[3].'>';
                $text = str_replace($match[0], $new, $text);
            }
        }

        //caption text in caption attribute
        preg_match_all('%(\[caption(.*)caption="(.*)"])(.*)<img(.*)/>(.*)(\[/caption])%', $text, $matches, PREG_SET_ORDER);
        if($matches) {
            foreach($matches as $match) {
                if(trim(strip_tags($match[3])) == "") continue;
                $new = $match[4] . '<img title="'.trim(strip_tags($match[3])).'" '.$match[5].'>';
                $text = str_replace($match[0], $new, $text);
            }
        }

        return $text;
    }

    // Wordpress [caption] align to CkEditor defaut img align attr
    function inlineAlign($text) {
        preg_match_all('%\[caption.* align="(.*)(<img.*?\/?>).*?\[\/caption]%', $text, $matches, PREG_SET_ORDER);
        if($matches) {
            foreach($matches as $match) {
                $text = str_replace($match[2], str_replace('class="', 'class="'.strstr($match[1], '"', true).' ', $match[2]), $text);
            }
        }
        //convert alignment classes from WP to default CkEditor classes in PW
        $text = str_replace("alignleft", "align_left", $text);
        $text = str_replace("alignright", "align_right", $text);
        $text = str_replace("aligncenter", "align_right", $text);

        return $text;
    }



    private function sortByPostType(array $posts) {
        // currently only attachment, post and page are valid post types (no support for custom types)

        $sorted = array();

        foreach($posts as $post) {
            $sorted[$post['post_type']][] = $post;
        }

        return $sorted;
    }



    private function getPostCategories($post) {
        $data = @$post['terms'];
        $categories = array();

        if($data) {
            foreach($data as $term) {
                if($term['domain'] == 'category') {
                    $categories[] = $this->cleanPageName($term['slug']);
                }
            }
        }

        return $categories;
    }



    private function getPostTags($post) {
        $data = @$post['terms'];
        $tags = array();

        if($data) {
            foreach($data as $term) {
                if($term['domain'] == 'post_tag') {
                    $tags[] = $this->cleanPageName($term['slug']);
                }
            }
        }

        return $tags;
    }



    private function getStatus($wpStatus) {
        // Publish - Viewable by everyone.
        if($wpStatus == 'publish') return 1;

        // Future - Scheduled to be published in a future date.
        if($wpStatus == 'future') return 3073;

        // Draft - Incomplete post viewable by anyone with proper user level.
        if($wpStatus == 'draft') return 1025;

        // Pending - Awaiting a user with the publish_posts capability (typically a user assigned the Editor role) to publish.
        if($wpStatus == 'pending') return 1025;

        // Private - Viewable only to WordPress users at Administrator level.
        if($wpStatus == 'private') return 3073;

        // Trash - Posts in the Trash are assigned the trash status.
        if($wpStatus == 'trash') return false; // I don't need trashed pages to get imported

        // Auto-Draft - Revisions that WordPress saves automatically while you are editing.
        if($wpStatus == 'auto-draft') return 3073;

        // Inherit - Used with a child post (such as Attachments and Revisions) to determine the actual status from the parent post.
        if($wpStatus == 'inherit') return 1;


        return false;
    }


    private function cleanPageName($name) {
        $name = rawurldecode($name);
        $name = wire('sanitizer')->pageName($name, true);

        return $name;
    }


    private function populateDefault($data) {
        $default = $this->default;
        $dataSplitted = array();

        // split data
        foreach($data as $fieldKey => $fieldValue) {
            $splitKey = explode('_', $fieldKey, 2);
            $dataSplitted[$splitKey[0]][$splitKey[1]] = $fieldValue;
        }
        // overwrite old $data
        $data = $dataSplitted;
        unset($dataSplitted);

        // populate
        foreach($default as $type => $childs) {
            foreach($childs as $child => $value) {
                $cData[$type][$child] = ((isset($data[$type][$child]) && $data[$type][$child] != '') ? $data[$type][$child] : $default[$type][$child]);
            }
        }

        return $cData;
    }




    // Config stuff

    public static function getModuleConfigInputfields(array $data) {
        $inputfields = new InputfieldWrapper();

        // Config
        $general = wire('modules')->get('InputfieldFieldset');
        $general->label = 'General Config';
        $general->description = '';

        $field = wire('modules')->get("InputfieldCheckbox");
        $field->name = 'general_convertshortcodes';
        $field->label = 'Convert Shortcodes';
        $field->description = "Check to have the import process convert WP single bracket [shortcode] format to match the default Hanna code double bracket [[shortcode]] format.";
        $field->attr('checked', isset($data['general_convertshortcodes']) && $data['general_convertshortcodes']=='1' ? 'checked' : '' );
        $general->add($field);

        $inputfields->add($general);

        // Fields
        $fields = wire('modules')->get('InputfieldFieldset');
        $fields->label = 'Fields';
        $fields->description = 'If you already have created the needed field or want to use custom names for them you can adjust them here.';
        $fields->notes = 'Please don\'t change anything if you don\'t know what you\'re doing.';

        $field = wire('modules')->get('InputfieldText');
        $field->name = 'field_title';
        $field->label = "title";
        $field->value = ((isset($data['field_title'])) ?  $data['field_title'] : 'title');
        $fields->add($field);

        $field = wire('modules')->get('InputfieldText');
        $field->name = 'field_date';
        $field->label = 'date';
        $field->value = ((isset($data['field_date'])) ?  $data['field_date'] : 'date');
        $fields->add($field);

        $field = wire('modules')->get('InputfieldText');
        $field->name = 'field_body';
        $field->label = 'body';
        $field->value = ((isset($data['field_body'])) ?  $data['field_body'] : 'body');
        $fields->add($field);

        $field = wire('modules')->get('InputfieldText');
        $field->name = 'field_headline';
        $field->label = 'headline';
        $field->value = ((isset($data['field_headline'])) ?  $data['field_headline'] : 'headline');
        $fields->add($field);

        $field = wire('modules')->get('InputfieldText');
        $field->name = 'field_images';
        $field->label = 'images';
        $field->value = ((isset($data['field_images'])) ?  $data['field_images'] : 'images');
        $fields->add($field);

        $field = wire('modules')->get('InputfieldText');
        $field->name = 'field_files';
        $field->label = 'files';
        $field->value = ((isset($data['field_files'])) ?  $data['field_files'] : 'files');
        $fields->add($field);

        //Comments
        $field=wire('modules')->get('InputfieldText');
        $field->name="field_comments";
        $field->label="Comments";
        $field->value=((isset($data['field_comments'])) ?  $data['field_comments'] : 'comments');
        $fields->add($field);

        $field = wire('modules')->get('InputfieldText');
        $field->name = 'field_categories';
        $field->label = 'categories';
        $field->value = ((isset($data['field_categories'])) ?  $data['field_categories'] : 'categories');
        $fields->add($field);

        $field = wire('modules')->get('InputfieldText');
        $field->name = 'field_tags';
        $field->label = 'tags';
        $field->value = ((isset($data['field_tags'])) ?  $data['field_tags'] : 'tags');
        $fields->add($field);

        $field = wire('modules')->get('InputfieldText');
        $field->name = 'field_excerpt';
        $field->label = 'excerpt';
        $field->value = ((isset($data['field_excerpt'])) ?  $data['field_excerpt'] : 'excerpt');
        $fields->add($field);

        $field = wire('modules')->get('InputfieldText');
        $field->name = 'field_wpid';
        $field->label = 'wpid';
        $field->value = ((isset($data['field_wpid'])) ?  $data['field_wpid'] : 'wpid');
        $fields->add($field);

        $inputfields->add($fields);


        // templates
        $fields = wire('modules')->get('InputfieldFieldset');
        $fields->label = 'Templates';
        $fields->description = 'If you already have created the needed templates or want to use custom names for them you can adjust them here.';
        $fields->notes = 'Please don\'t change anything if you don\'t know what you\'re doing.';

        $field = wire('modules')->get('InputfieldText');
        $field->name = 'template_tags';
        $field->label = 'tags';
        $field->value = ((isset($data['template_tags'])) ?  $data['template_tags'] : 'tags');
        $fields->add($field);

        $field = wire('modules')->get('InputfieldText');
        $field->name = 'template_tag';
        $field->label = 'tag';
        $field->value = ((isset($data['template_tag'])) ?  $data['template_tag'] : 'tag');
        $fields->add($field);

        $field = wire('modules')->get('InputfieldText');
        $field->name = 'template_categories';
        $field->label = 'categories';
        $field->value = ((isset($data['template_categories'])) ?  $data['template_categories'] : 'categories');
        $fields->add($field);

        $field = wire('modules')->get('InputfieldText');
        $field->name = 'template_category';
        $field->label = 'category';
        $field->value = ((isset($data['template_category'])) ?  $data['template_category'] : 'category');
        $fields->add($field);

        $field = wire('modules')->get('InputfieldText');
        $field->name = 'template_posts';
        $field->label = 'posts';
        $field->value = ((isset($data['template_posts'])) ?  $data['template_posts'] : 'posts');
        $fields->add($field);




        $field = wire('modules')->get('InputfieldText');
        $field->name = 'template_post';
        $field->label = 'post';
        $field->value = ((isset($data['template_post'])) ?  $data['template_post'] : 'post');
        $fields->add($field);

        $field = wire('modules')->get('InputfieldText');
        $field->name = 'template_blog-page';
        $field->label = 'blog-page';
        $field->value = ((isset($data['template_blog-page'])) ?  $data['template_blog-page'] : 'blog-page');
        $fields->add($field);

        $inputfields->add($fields);



        return $inputfields;
    }


}








/**
 * The following functions originally belong to "WordPress"
 * They are distributed under the "GNU General Public License"
 */

/**
 * Accepts matches array from preg_replace_callback in wpautop() or a string.
 *
 * Ensures that the contents of a <<pre>>...<</pre>> HTML block are not
 * converted into paragraphs or line-breaks.
 *
 * @param array|string $matches The array or string
 * @return string The pre block without paragraph/line-break conversion.
 */
function clean_pre($matches) {
    if ( is_array($matches) )
        $text = $matches[1] . $matches[2] . "</pre>";
    else
        $text = $matches;

    $text = str_replace('<br />', '', $text);
    $text = str_replace('<p>', "\n", $text);
    $text = str_replace('</p>', '', $text);

    return $text;
}


/**
 * Replaces double line-breaks with paragraph elements.
 *
 * A group of regex replaces used to identify text formatted with newlines and
 * replace double line-breaks with HTML paragraph tags. The remaining
 * line-breaks after conversion become <<br />> tags, unless $br is set to '0'
 * or 'false'.
 *
 * @param string $pee The text which has to be formatted.
 * @param int|bool $br Optional. If set, this will convert all remaining line-breaks after paragraphing. Default true.
 * @return string Text which has been converted into correct paragraph tags.
 */
function autop($pee, $br = 1) {

    if ( trim($pee) === '' )
        return '';
    $pee = $pee . "\n"; // just to make things a little easier, pad the end
    $pee = preg_replace('|<br />\s*<br />|', "\n\n", $pee);
    // Space things out a little
    $allblocks = '(?:table|thead|tfoot|caption|col|colgroup|tbody|tr|td|th|div|dl|dd|dt|ul|ol|li|pre|select|option|form|map|area|blockquote|address|math|style|input|p|h[1-6]|hr|fieldset|legend|section|article|aside|hgroup|header|footer|nav|figure|figcaption|details|menu|summary)';
    $pee = preg_replace('!(<' . $allblocks . '[^>]*>)!', "\n$1", $pee);
    $pee = preg_replace('!(</' . $allblocks . '>)!', "$1\n\n", $pee);
    $pee = str_replace(array("\r\n", "\r"), "\n", $pee); // cross-platform newlines
    if ( strpos($pee, '<object') !== false ) {
        $pee = preg_replace('|\s*<param([^>]*)>\s*|', "<param$1>", $pee); // no pee inside object/embed
        $pee = preg_replace('|\s*</embed>\s*|', '</embed>', $pee);
    }
    $pee = preg_replace("/\n\n+/", "\n\n", $pee); // take care of duplicates
    // make paragraphs, including one at the end
    $pees = preg_split('/\n\s*\n/', $pee, -1, PREG_SPLIT_NO_EMPTY);
    $pee = '';
    foreach ( $pees as $tinkle )
        $pee .= '<p>' . trim($tinkle, "\n") . "</p>\n";
    $pee = preg_replace('|<p>\s*</p>|', '', $pee); // under certain strange conditions it could create a P of entirely whitespace
    $pee = preg_replace('!<p>([^<]+)</(div|address|form)>!', "<p>$1</p></$2>", $pee);
    $pee = preg_replace('!<p>\s*(</?' . $allblocks . '[^>]*>)\s*</p>!', "$1", $pee); // don't pee all over a tag
    $pee = preg_replace("|<p>(<li.+?)</p>|", "$1", $pee); // problem with nested lists
    $pee = preg_replace('|<p><blockquote([^>]*)>|i', "<blockquote$1><p>", $pee);
    $pee = str_replace('</blockquote></p>', '</p></blockquote>', $pee);
    $pee = preg_replace('!<p>\s*(</?' . $allblocks . '[^>]*>)!', "$1", $pee);
    $pee = preg_replace('!(</?' . $allblocks . '[^>]*>)\s*</p>!', "$1", $pee);
    if ($br) {
        $pee = preg_replace_callback('/<(script|style).*?<\/\\1>/s', '_autop_newline_preservation_helper', $pee);
        $pee = preg_replace('|(?<!<br />)\s*\n|', "<br />\n", $pee); // optionally make line breaks
        $pee = str_replace('<WPPreserveNewline />', "\n", $pee);
    }
    $pee = preg_replace('!(</?' . $allblocks . '[^>]*>)\s*<br />!', "$1", $pee);
    $pee = preg_replace('!<br />(\s*</?(?:p|li|div|dl|dd|dt|th|pre|td|ul|ol)[^>]*>)!', '$1', $pee);
    if (strpos($pee, '<pre') !== false)
        $pee = preg_replace_callback('!(<pre[^>]*>)(.*?)</pre>!is', 'clean_pre', $pee );
    $pee = preg_replace( "|\n</p>$|", '</p>', $pee );

    return $pee;
}

/**
 * Newline preservation help function for wpautop
 *
 * @access private
 * @param array $matches preg_replace_callback matches array
 * @returns string
 */
function _autop_newline_preservation_helper( $matches ) {
    return str_replace("\n", "<PreserveNewline />", $matches[0]);
}







/**
 * WordPress eXtended RSS file parser implementations
 *
 * @package WordPress
 * @subpackage Importer
 */

/**
 * WordPress Importer class for managing parsing of WXR files.
 */
class WXR_Parser {
    function parse( $file ) {
        // Attempt to use proper XML parsers first
        if ( extension_loaded( 'simplexml' ) ) {
            $parser = new WXR_Parser_SimpleXML;
            $result = $parser->parse( $file );

            // If SimpleXML succeeds or this is an invalid WXR file then return the results
            if ( $result != false )
                return $result;
        } else if ( extension_loaded( 'xml' ) ) {
            $parser = new WXR_Parser_XML;
            $result = $parser->parse( $file );

            // If XMLParser succeeds or this is an invalid WXR file then return the results
            if ( $result != false )
                return $result;
        }
        /*
                // We have a malformed XML file, so display the error and fallthrough to regex
                if ( isset($result) && defined('IMPORT_DEBUG') && IMPORT_DEBUG ) {
                    echo '<pre>';
                    if ( 'SimpleXML_parse_error' == $result->get_error_code() ) {
                        foreach  ( $result->get_error_data() as $error )
                            echo $error->line . ':' . $error->column . ' ' . esc_html( $error->message ) . "\n";
                    } else if ( 'XML_parse_error' == $result->get_error_code() ) {
                        $error = $result->get_error_data();
                        echo $error[0] . ':' . $error[1] . ' ' . esc_html( $error[2] );
                    }
                    echo '</pre>';
                    echo '<p><strong>' . __( 'There was an error when reading this WXR file', 'wordpress-importer' ) . '</strong><br />';
                    echo __( 'Details are shown above. The importer will now try again with a different parser...', 'wordpress-importer' ) . '</p>';
                }
        */

        // use regular expressions if nothing else available or this is bad XML
        $parser = new WXR_Parser_Regex;
        return $parser->parse( $file );
    }
}

/**
 * WXR Parser that makes use of the SimpleXML PHP extension.
 */
class WXR_Parser_SimpleXML {
    function parse( $file ) {
        $authors = $posts = $categories = $tags = $terms = array();

        $internal_errors = libxml_use_internal_errors(true);

        $dom = new DOMDocument;
        $old_value = null;
        if ( function_exists( 'libxml_disable_entity_loader' ) ) {
            $old_value = libxml_disable_entity_loader( true );
        }
        $success = $dom->loadXML( file_get_contents( $file ) );
        if ( ! is_null( $old_value ) ) {
            libxml_disable_entity_loader( $old_value );
        }

        if ( ! $success || isset( $dom->doctype ) ) {
            return false; // false; //new WireException( __( 'There was an error when reading this WXR file', 'wordpress-importer' ), libxml_get_errors() );
        }

        $xml = simplexml_import_dom( $dom );
        unset( $dom );

        // halt if loading produces an error
        if ( ! $xml )
            return  false; //new WireException( __( 'There was an error when reading this WXR file', 'wordpress-importer' ), libxml_get_errors() );

        $wxr_version = $xml->xpath('/rss/channel/wp:wxr_version');
        if ( ! $wxr_version )
            return  false; //new WireException( __( 'This does not appear to be a WXR file, missing/invalid WXR version number', 'wordpress-importer' ) );

        $wxr_version = (string) trim( $wxr_version[0] );
        // confirm that we are dealing with the correct file format
        if ( ! preg_match( '/^\d+\.\d+$/', $wxr_version ) )
            return  false; //new WireException( __( 'This does not appear to be a WXR file, missing/invalid WXR version number', 'wordpress-importer' ) );

        $base_url = $xml->xpath('/rss/channel/wp:base_site_url');
        $base_url = (string) trim( $base_url[0] );

        $namespaces = $xml->getDocNamespaces();
        if ( ! isset( $namespaces['wp'] ) )
            $namespaces['wp'] = 'http://wordpress.org/export/1.1/';
        if ( ! isset( $namespaces['excerpt'] ) )
            $namespaces['excerpt'] = 'http://wordpress.org/export/1.1/excerpt/';

        // grab authors
        foreach ( $xml->xpath('/rss/channel/wp:author') as $author_arr ) {
            $a = $author_arr->children( $namespaces['wp'] );
            $login = (string) $a->author_login;
            $authors[$login] = array(
                'author_id' => (int) $a->author_id,
                'author_login' => $login,
                'author_email' => (string) $a->author_email,
                'author_display_name' => (string) $a->author_display_name,
                'author_first_name' => (string) $a->author_first_name,
                'author_last_name' => (string) $a->author_last_name
            );
        }

        // grab cats, tags and terms
        foreach ( $xml->xpath('/rss/channel/wp:category') as $term_arr ) {
            $t = $term_arr->children( $namespaces['wp'] );
            $categories[] = array(
                'term_id' => (int) $t->term_id,
                'category_nicename' => (string) $t->category_nicename,
                'category_parent' => (string) $t->category_parent,
                'cat_name' => (string) $t->cat_name,
                'category_description' => (string) $t->category_description
            );
        }

        foreach ( $xml->xpath('/rss/channel/wp:tag') as $term_arr ) {
            $t = $term_arr->children( $namespaces['wp'] );
            $tags[] = array(
                'term_id' => (int) $t->term_id,
                'tag_slug' => (string) $t->tag_slug,
                'tag_name' => (string) $t->tag_name,
                'tag_description' => (string) $t->tag_description
            );
        }

        foreach ( $xml->xpath('/rss/channel/wp:term') as $term_arr ) {
            $t = $term_arr->children( $namespaces['wp'] );
            $terms[] = array(
                'term_id' => (int) $t->term_id,
                'term_taxonomy' => (string) $t->term_taxonomy,
                'slug' => (string) $t->term_slug,
                'term_parent' => (string) $t->term_parent,
                'term_name' => (string) $t->term_name,
                'term_description' => (string) $t->term_description
            );
        }

        // grab posts
        foreach ( $xml->channel->item as $item ) {
            $post = array(
                'post_title' => (string) $item->title,
                'guid' => (string) $item->guid,
            );

            $dc = $item->children( 'http://purl.org/dc/elements/1.1/' );
            $post['post_author'] = (string) $dc->creator;

            $content = $item->children( 'http://purl.org/rss/1.0/modules/content/' );
            $excerpt = $item->children( $namespaces['excerpt'] );
            $post['post_content'] = (string) $content->encoded;
            $post['post_excerpt'] = (string) $excerpt->encoded;

            $wp = $item->children( $namespaces['wp'] );
            $post['post_id'] = (int) $wp->post_id;
            $post['post_date'] = (string) $wp->post_date;
            $post['post_date_gmt'] = (string) $wp->post_date_gmt;
            $post['comment_status'] = (string) $wp->comment_status;
            $post['ping_status'] = (string) $wp->ping_status;
            $post['post_name'] = (string) $wp->post_name;
            $post['status'] = (string) $wp->status;
            $post['post_parent'] = (int) $wp->post_parent;
            $post['menu_order'] = (int) $wp->menu_order;
            $post['post_type'] = (string) $wp->post_type;
            $post['post_password'] = (string) $wp->post_password;
            $post['is_sticky'] = (int) $wp->is_sticky;

            if ( isset($wp->attachment_url) )
                $post['attachment_url'] = (string) $wp->attachment_url;

            foreach ( $item->category as $c ) {
                $att = $c->attributes();
                if ( isset( $att['nicename'] ) )
                    $post['terms'][] = array(
                        'name' => (string) $c,
                        'slug' => (string) $att['nicename'],
                        'domain' => (string) $att['domain']
                    );
            }

            foreach ( $wp->postmeta as $meta ) {
                $post['postmeta'][] = array(
                    'key' => (string) $meta->meta_key,
                    'value' => (string) $meta->meta_value
                );
            }

            foreach ( $wp->comment as $comment ) {
                $meta = array();
                if ( isset( $comment->commentmeta ) ) {
                    foreach ( $comment->commentmeta as $m ) {
                        $meta[] = array(
                            'key' => (string) $m->meta_key,
                            'value' => (string) $m->meta_value
                        );
                    }
                }

                $post['comments'][] = array(
                    'comment_id' => (int) $comment->comment_id,
                    'comment_author' => (string) $comment->comment_author,
                    'comment_author_email' => (string) $comment->comment_author_email,
                    'comment_author_IP' => (string) $comment->comment_author_IP,
                    'comment_author_url' => (string) $comment->comment_author_url,
                    'comment_date' => (string) $comment->comment_date,
                    'comment_date_gmt' => (string) $comment->comment_date_gmt,
                    'comment_content' => (string) $comment->comment_content,
                    'comment_approved' => (string) $comment->comment_approved,
                    'comment_type' => (string) $comment->comment_type,
                    'comment_parent' => (string) $comment->comment_parent,
                    'comment_user_id' => (int) $comment->comment_user_id,
                    'commentmeta' => $meta,
                );
            }

            $posts[] = $post;
        }

        return array(
            'authors' => $authors,
            'posts' => $posts,
            'categories' => $categories,
            'tags' => $tags,
            'terms' => $terms,
            'base_url' => $base_url,
            'version' => $wxr_version
        );
    }
}

/**
 * WXR Parser that makes use of the XML Parser PHP extension.
 */
class WXR_Parser_XML {
    var $wp_tags = array(
        'wp:post_id', 'wp:post_date', 'wp:post_date_gmt', 'wp:comment_status', 'wp:ping_status', 'wp:attachment_url',
        'wp:status', 'wp:post_name', 'wp:post_parent', 'wp:menu_order', 'wp:post_type', 'wp:post_password',
        'wp:is_sticky', 'wp:term_id', 'wp:category_nicename', 'wp:category_parent', 'wp:cat_name', 'wp:category_description',
        'wp:tag_slug', 'wp:tag_name', 'wp:tag_description', 'wp:term_taxonomy', 'wp:term_parent',
        'wp:term_name', 'wp:term_description', 'wp:author_id', 'wp:author_login', 'wp:author_email', 'wp:author_display_name',
        'wp:author_first_name', 'wp:author_last_name',
    );
    var $wp_sub_tags = array(
        'wp:comment_id', 'wp:comment_author', 'wp:comment_author_email', 'wp:comment_author_url',
        'wp:comment_author_IP', 'wp:comment_date', 'wp:comment_date_gmt', 'wp:comment_content',
        'wp:comment_approved', 'wp:comment_type', 'wp:comment_parent', 'wp:comment_user_id',
    );

    function parse( $file ) {
        $this->wxr_version = $this->in_post = $this->cdata = $this->data = $this->sub_data = $this->in_tag = $this->in_sub_tag = false;
        $this->authors = $this->posts = $this->term = $this->category = $this->tag = array();

        $xml = xml_parser_create( 'UTF-8' );
        xml_parser_set_option( $xml, XML_OPTION_SKIP_WHITE, 1 );
        xml_parser_set_option( $xml, XML_OPTION_CASE_FOLDING, 0 );
        xml_set_object( $xml, $this );
        xml_set_character_data_handler( $xml, 'cdata' );
        xml_set_element_handler( $xml, 'tag_open', 'tag_close' );

        if ( ! xml_parse( $xml, file_get_contents( $file ), true ) ) {
            $current_line = xml_get_current_line_number( $xml );
            $current_column = xml_get_current_column_number( $xml );
            $error_code = xml_get_error_code( $xml );
            $error_string = xml_error_string( $error_code );
            return  false; //new WireException( 'There was an error when reading this WXR file', array( $current_line, $current_column, $error_string ) );
        }
        xml_parser_free( $xml );

        if ( ! preg_match( '/^\d+\.\d+$/', $this->wxr_version ) )
            return  false; //new WireException( __( 'This does not appear to be a WXR file, missing/invalid WXR version number', 'wordpress-importer' ) );

        return array(
            'authors' => $this->authors,
            'posts' => $this->posts,
            'categories' => $this->category,
            'tags' => $this->tag,
            'terms' => $this->term,
            'base_url' => $this->base_url,
            'version' => $this->wxr_version
        );
    }

    function tag_open( $parse, $tag, $attr ) {
        if ( in_array( $tag, $this->wp_tags ) ) {
            $this->in_tag = substr( $tag, 3 );
            return;
        }

        if ( in_array( $tag, $this->wp_sub_tags ) ) {
            $this->in_sub_tag = substr( $tag, 3 );
            return;
        }

        switch ( $tag ) {
            case 'category':
                if ( isset($attr['domain'], $attr['nicename']) ) {
                    $this->sub_data['domain'] = $attr['domain'];
                    $this->sub_data['slug'] = $attr['nicename'];
                }
                break;
            case 'item': $this->in_post = true;
            case 'title': if ( $this->in_post ) $this->in_tag = 'post_title'; break;
            case 'guid': $this->in_tag = 'guid'; break;
            case 'dc:creator': $this->in_tag = 'post_author'; break;
            case 'content:encoded': $this->in_tag = 'post_content'; break;
            case 'excerpt:encoded': $this->in_tag = 'post_excerpt'; break;

            case 'wp:term_slug': $this->in_tag = 'slug'; break;
            case 'wp:meta_key': $this->in_sub_tag = 'key'; break;
            case 'wp:meta_value': $this->in_sub_tag = 'value'; break;
        }
    }

    function cdata( $parser, $cdata ) {
        if ( ! trim( $cdata ) )
            return;

        $this->cdata .= trim( $cdata );
    }

    function tag_close( $parser, $tag ) {
        switch ( $tag ) {
            case 'wp:comment':
                unset( $this->sub_data['key'], $this->sub_data['value'] ); // remove meta sub_data
                if ( ! empty( $this->sub_data ) )
                    $this->data['comments'][] = $this->sub_data;
                $this->sub_data = false;
                break;
            case 'wp:commentmeta':
                $this->sub_data['commentmeta'][] = array(
                    'key' => $this->sub_data['key'],
                    'value' => $this->sub_data['value']
                );
                break;
            case 'category':
                if ( ! empty( $this->sub_data ) ) {
                    $this->sub_data['name'] = $this->cdata;
                    $this->data['terms'][] = $this->sub_data;
                }
                $this->sub_data = false;
                break;
            case 'wp:postmeta':
                if ( ! empty( $this->sub_data ) )
                    $this->data['postmeta'][] = $this->sub_data;
                $this->sub_data = false;
                break;
            case 'item':
                $this->posts[] = $this->data;
                $this->data = false;
                break;
            case 'wp:category':
            case 'wp:tag':
            case 'wp:term':
                $n = substr( $tag, 3 );
                array_push( $this->$n, $this->data );
                $this->data = false;
                break;
            case 'wp:author':
                if ( ! empty($this->data['author_login']) )
                    $this->authors[$this->data['author_login']] = $this->data;
                $this->data = false;
                break;
            case 'wp:base_site_url':
                $this->base_url = $this->cdata;
                break;
            case 'wp:wxr_version':
                $this->wxr_version = $this->cdata;
                break;

            default:
                if ( $this->in_sub_tag ) {
                    $this->sub_data[$this->in_sub_tag] = ! empty( $this->cdata ) ? $this->cdata : '';
                    $this->in_sub_tag = false;
                } else if ( $this->in_tag ) {
                    $this->data[$this->in_tag] = ! empty( $this->cdata ) ? $this->cdata : '';
                    $this->in_tag = false;
                }
        }

        $this->cdata = false;
    }
}

/**
 * WXR Parser that uses regular expressions. Fallback for installs without an XML parser.
 */
class WXR_Parser_Regex {
    var $authors = array();
    var $posts = array();
    var $categories = array();
    var $tags = array();
    var $terms = array();
    var $base_url = '';

    /*function WXR_Parser_Regex() {
        $this->__construct();
    }*/

    function __construct() {
        $this->has_gzip = is_callable( 'gzopen' );
    }

    function parse( $file ) {
        $wxr_version = $in_post = false;

        $fp = $this->fopen( $file, 'r' );
        if ( $fp ) {
            while ( ! $this->feof( $fp ) ) {
                $importline = rtrim( $this->fgets( $fp ) );

                if ( ! $wxr_version && preg_match( '|<wp:wxr_version>(\d+\.\d+)</wp:wxr_version>|', $importline, $version ) )
                    $wxr_version = $version[1];

                if ( false !== strpos( $importline, '<wp:base_site_url>' ) ) {
                    preg_match( '|<wp:base_site_url>(.*?)</wp:base_site_url>|is', $importline, $url );
                    $this->base_url = $url[1];
                    continue;
                }
                if ( false !== strpos( $importline, '<wp:category>' ) ) {
                    preg_match( '|<wp:category>(.*?)</wp:category>|is', $importline, $category );
                    $this->categories[] = $this->process_category( $category[1] );
                    continue;
                }
                if ( false !== strpos( $importline, '<wp:tag>' ) ) {
                    preg_match( '|<wp:tag>(.*?)</wp:tag>|is', $importline, $tag );
                    $this->tags[] = $this->process_tag( $tag[1] );
                    continue;
                }
                if ( false !== strpos( $importline, '<wp:term>' ) ) {
                    preg_match( '|<wp:term>(.*?)</wp:term>|is', $importline, $term );
                    $this->terms[] = $this->process_term( $term[1] );
                    continue;
                }
                if ( false !== strpos( $importline, '<wp:author>' ) ) {
                    preg_match( '|<wp:author>(.*?)</wp:author>|is', $importline, $author );
                    $a = $this->process_author( $author[1] );
                    $this->authors[$a['author_login']] = $a;
                    continue;
                }
                if ( false !== strpos( $importline, '<item>' ) ) {
                    $post = '';
                    $in_post = true;
                    continue;
                }
                if ( false !== strpos( $importline, '</item>' ) ) {
                    $in_post = false;
                    $this->posts[] = $this->process_post( $post );
                    continue;
                }
                if ( $in_post ) {
                    $post .= $importline . "\n";
                }
            }

            $this->fclose($fp);
        }

        if ( ! $wxr_version )
            return  false; //new WireException( __( 'This does not appear to be a WXR file, missing/invalid WXR version number', 'wordpress-importer' ) );

        return array(
            'authors' => $this->authors,
            'posts' => $this->posts,
            'categories' => $this->categories,
            'tags' => $this->tags,
            'terms' => $this->terms,
            'base_url' => $this->base_url,
            'version' => $wxr_version
        );
    }

    function get_tag( $string, $tag ) {
        preg_match( "|<$tag.*?>(.*?)</$tag>|is", $string, $return );
        if ( isset( $return[1] ) ) {
            if ( substr( $return[1], 0, 9 ) == '<![CDATA[' ) {
                if ( strpos( $return[1], ']]]]><![CDATA[>' ) !== false ) {
                    preg_match_all( '|<!\[CDATA\[(.*?)\]\]>|s', $return[1], $matches );
                    $return = '';
                    foreach( $matches[1] as $match )
                        $return .= $match;
                } else {
                    $return = preg_replace( '|^<!\[CDATA\[(.*)\]\]>$|s', '$1', $return[1] );
                }
            } else {
                $return = $return[1];
            }
        } else {
            $return = '';
        }
        return $return;
    }

    function process_category( $c ) {
        return array(
            'term_id' => $this->get_tag( $c, 'wp:term_id' ),
            'cat_name' => $this->get_tag( $c, 'wp:cat_name' ),
            'category_nicename' => $this->get_tag( $c, 'wp:category_nicename' ),
            'category_parent' => $this->get_tag( $c, 'wp:category_parent' ),
            'category_description' => $this->get_tag( $c, 'wp:category_description' ),
        );
    }

    function process_tag( $t ) {
        return array(
            'term_id' => $this->get_tag( $t, 'wp:term_id' ),
            'tag_name' => $this->get_tag( $t, 'wp:tag_name' ),
            'tag_slug' => $this->get_tag( $t, 'wp:tag_slug' ),
            'tag_description' => $this->get_tag( $t, 'wp:tag_description' ),
        );
    }

    function process_term( $t ) {
        return array(
            'term_id' => $this->get_tag( $t, 'wp:term_id' ),
            'term_taxonomy' => $this->get_tag( $t, 'wp:term_taxonomy' ),
            'slug' => $this->get_tag( $t, 'wp:term_slug' ),
            'term_parent' => $this->get_tag( $t, 'wp:term_parent' ),
            'term_name' => $this->get_tag( $t, 'wp:term_name' ),
            'term_description' => $this->get_tag( $t, 'wp:term_description' ),
        );
    }

    function process_author( $a ) {
        return array(
            'author_id' => $this->get_tag( $a, 'wp:author_id' ),
            'author_login' => $this->get_tag( $a, 'wp:author_login' ),
            'author_email' => $this->get_tag( $a, 'wp:author_email' ),
            'author_display_name' => $this->get_tag( $a, 'wp:author_display_name' ),
            'author_first_name' => $this->get_tag( $a, 'wp:author_first_name' ),
            'author_last_name' => $this->get_tag( $a, 'wp:author_last_name' ),
        );
    }

    function process_post( $post ) {
        $post_id        = $this->get_tag( $post, 'wp:post_id' );
        $post_title     = $this->get_tag( $post, 'title' );
        $post_date      = $this->get_tag( $post, 'wp:post_date' );
        $post_date_gmt  = $this->get_tag( $post, 'wp:post_date_gmt' );
        $comment_status = $this->get_tag( $post, 'wp:comment_status' );
        $ping_status    = $this->get_tag( $post, 'wp:ping_status' );
        $status         = $this->get_tag( $post, 'wp:status' );
        $post_name      = $this->get_tag( $post, 'wp:post_name' );
        $post_parent    = $this->get_tag( $post, 'wp:post_parent' );
        $menu_order     = $this->get_tag( $post, 'wp:menu_order' );
        $post_type      = $this->get_tag( $post, 'wp:post_type' );
        $post_password  = $this->get_tag( $post, 'wp:post_password' );
        $is_sticky      = $this->get_tag( $post, 'wp:is_sticky' );
        $guid           = $this->get_tag( $post, 'guid' );
        $post_author    = $this->get_tag( $post, 'dc:creator' );

        $post_excerpt = $this->get_tag( $post, 'excerpt:encoded' );
        $post_excerpt = preg_replace_callback( '|<(/?[A-Z]+)|', array( &$this, '_normalize_tag' ), $post_excerpt );
        $post_excerpt = str_replace( '<br>', '<br />', $post_excerpt );
        $post_excerpt = str_replace( '<hr>', '<hr />', $post_excerpt );

        $post_content = $this->get_tag( $post, 'content:encoded' );
        $post_content = preg_replace_callback( '|<(/?[A-Z]+)|', array( &$this, '_normalize_tag' ), $post_content );
        $post_content = str_replace( '<br>', '<br />', $post_content );
        $post_content = str_replace( '<hr>', '<hr />', $post_content );

        $postdata = compact( 'post_id', 'post_author', 'post_date', 'post_date_gmt', 'post_content', 'post_excerpt',
            'post_title', 'status', 'post_name', 'comment_status', 'ping_status', 'guid', 'post_parent',
            'menu_order', 'post_type', 'post_password', 'is_sticky'
        );

        $attachment_url = $this->get_tag( $post, 'wp:attachment_url' );
        if ( $attachment_url )
            $postdata['attachment_url'] = $attachment_url;

        preg_match_all( '|<category domain="([^"]+?)" nicename="([^"]+?)">(.+?)</category>|is', $post, $terms, PREG_SET_ORDER );
        foreach ( $terms as $t ) {
            $post_terms[] = array(
                'slug' => $t[2],
                'domain' => $t[1],
                'name' => str_replace( array( '<![CDATA[', ']]>' ), '', $t[3] ),
            );
        }
        if ( ! empty( $post_terms ) ) $postdata['terms'] = $post_terms;

        preg_match_all( '|<wp:comment>(.+?)</wp:comment>|is', $post, $comments );
        $comments = $comments[1];
        if ( $comments ) {
            foreach ( $comments as $comment ) {
                preg_match_all( '|<wp:commentmeta>(.+?)</wp:commentmeta>|is', $comment, $commentmeta );
                $commentmeta = $commentmeta[1];
                $c_meta = array();
                foreach ( $commentmeta as $m ) {
                    $c_meta[] = array(
                        'key' => $this->get_tag( $m, 'wp:meta_key' ),
                        'value' => $this->get_tag( $m, 'wp:meta_value' ),
                    );
                }

                $post_comments[] = array(
                    'comment_id' => $this->get_tag( $comment, 'wp:comment_id' ),
                    'comment_author' => $this->get_tag( $comment, 'wp:comment_author' ),
                    'comment_author_email' => $this->get_tag( $comment, 'wp:comment_author_email' ),
                    'comment_author_IP' => $this->get_tag( $comment, 'wp:comment_author_IP' ),
                    'comment_author_url' => $this->get_tag( $comment, 'wp:comment_author_url' ),
                    'comment_date' => $this->get_tag( $comment, 'wp:comment_date' ),
                    'comment_date_gmt' => $this->get_tag( $comment, 'wp:comment_date_gmt' ),
                    'comment_content' => $this->get_tag( $comment, 'wp:comment_content' ),
                    'comment_approved' => $this->get_tag( $comment, 'wp:comment_approved' ),
                    'comment_type' => $this->get_tag( $comment, 'wp:comment_type' ),
                    'comment_parent' => $this->get_tag( $comment, 'wp:comment_parent' ),
                    'comment_user_id' => $this->get_tag( $comment, 'wp:comment_user_id' ),
                    'commentmeta' => $c_meta,
                );
            }
        }
        if ( ! empty( $post_comments ) ) $postdata['comments'] = $post_comments;

        preg_match_all( '|<wp:postmeta>(.+?)</wp:postmeta>|is', $post, $postmeta );
        $postmeta = $postmeta[1];
        if ( $postmeta ) {
            foreach ( $postmeta as $p ) {
                $post_postmeta[] = array(
                    'key' => $this->get_tag( $p, 'wp:meta_key' ),
                    'value' => $this->get_tag( $p, 'wp:meta_value' ),
                );
            }
        }
        if ( ! empty( $post_postmeta ) ) $postdata['postmeta'] = $post_postmeta;

        return $postdata;
    }

    function _normalize_tag( $matches ) {
        return '<' . strtolower( $matches[1] );
    }

    function fopen( $filename, $mode = 'r' ) {
        if ( $this->has_gzip )
            return gzopen( $filename, $mode );
        return fopen( $filename, $mode );
    }

    function feof( $fp ) {
        if ( $this->has_gzip )
            return gzeof( $fp );
        return feof( $fp );
    }

    function fgets( $fp, $len = 8192 ) {
        if ( $this->has_gzip )
            return gzgets( $fp, $len );
        return fgets( $fp, $len );
    }

    function fclose( $fp ) {
        if ( $this->has_gzip )
            return gzclose( $fp );
        return fclose( $fp );
    }
}